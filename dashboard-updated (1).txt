import { useEffect, useState } from "react";
import { Box, Select, MenuItem, Typography, ListSubheader, TextField, InputAdornment, Tabs, Tab } from "@mui/material";
import axios from "axios";
import { useTheme } from "@emotion/react";
import SearchIcon from "@mui/icons-material/Search";
import PushPinIcon from '@mui/icons-material/PushPin';
import DataCard from "../components/DataCard";

interface TabPanelProps {
    children?: React.ReactNode;
    index: number;
    value: number;
}

function TabPanel(props: TabPanelProps) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`metrics-tabpanel-${index}`}
            aria-labelledby={`metrics-tab-${index}`}
            {...other}
        >
            {value === index && (
                <Box sx={{ p: 3 }}>
                    {children}
                </Box>
            )}
        </div>
    );
}

interface SavedMapping {
  org: string;
  projectList: Record<string, {
    teams: string[];
    members: Record<string, string[]>;
  }>;
}

// Define metric display configurations
const metricDisplayConfig = {
    "BugsResolvedCount": {
        displayName: "Bugs Resolved Count",
        category: "Efficiency",
        backgroundColor: "orange",
        borderColor: "darkorange"
    },
    "MeanTimeToResolve": {
        displayName: "MTTR",
        category: "Efficiency",
        backgroundColor: "rgba(0, 76, 255, 0.4)",
        borderColor: "rgb(0, 7, 99)"
    },
    "BugsEscapeRate": {
        displayName: "Bugs Escape Rate",
        category: "Quality",
        backgroundColor: "orange",
        borderColor: "darkorange"
    },
    "EpicsDelivered": {
        displayName: "Epics Delivered",
        category: "Development",
        backgroundColor: "rgba(255, 206, 86, 0.4)",
        borderColor: "rgba(255, 206, 86, 1)"
    },
    "DevelopmentCycleTime": {
        displayName: "Development Cycle Time",
        category: "Development",
        backgroundColor: "rgba(75, 192, 192, 0.4)",
        borderColor: "rgba(75, 192, 192, 1)"
    },
    "StoriesDelivered": {
        displayName: "Stories Delivered",
        category: "Development",
        backgroundColor: "rgba(153, 102, 255, 0.4)",
        borderColor: "rgba(153, 102, 255, 1)"
    },
    "StoryPointsCompleted": {
        displayName: "Story Points Completed",
        category: "Development",
        backgroundColor: "rgba(255, 99, 132, 0.4)",
        borderColor: "rgba(255, 99, 132, 1)"
    }
};

// Map tab indices to category names
const tabCategories = {
    0: "Favorites",
    1: "Efficiency",
    2: "Quality",
    3: "Development",
    4: "Innovation",
    5: "Support"
};

export default function Dashboard({ org = "", setOrg, team = "", setTeam, selectId = "", setselectId }) {
    const [errorMessage, setErrorMessage] = useState("");
    const [monthlyMetrics, setMonthlyMetrics] = useState(null);
    const [searchText, setSearchText] = useState("");
    const [idSearchText, setIdSearchText] = useState("");
    const [teamSearchText, setTeamSearchText] = useState("");
    const [currentTab, setCurrentTab] = useState(1);
    const [pinnedMetrics, setPinnedMetrics] = useState<string[]>([]);
    const [year, setYear] = useState('2024');
    const [notes, setNotes] = useState({});
    
    const theme = useTheme();

    // New state to hold metrics for both years, keyed by year string
    const [metricsData, setMetricsData] = useState<any>(null);

    const handleOrgChange = (event) => {
        setOrg(event.target.value);
        setselectId(""); // Reset selectId when org changes
        setTeam(""); // Reset team when org changes
    }

    const handleIdChange = (event) => {
        setselectId(event.target.value);
        setTeam(""); // Reset team when selectId changes
    }

    const handleTeamChange = (event) => {
        setTeam(event.target.value);
    }

    const handleTabChange = (event, newValue) => {
        setCurrentTab(newValue);
    };

    useEffect(() => {
        console.log("org: ", org);
        console.log("selectId: ", selectId);    
        console.log("team: ", team);
    }, [org, selectId, team]);

    const handlePin = (metric) => {
        setPinnedMetrics((prev) => 
            prev.includes(metric) ? prev.filter((m) => m !== metric) : [...prev, metric]
        );
    }

    const handleNoteChange = (metric, value) => {
        setNotes((prev) => ({
            ...prev,
            [metric]: value,
        }));
    };

    // --- Fetch metrics data only once and store both years ---
    useEffect(() => {
      const fetchMetrics = async () => {
         try {
             const response = await axios.get("http://localhost:5000/metrics");
             // Convert the returned array into an object keyed by year
             const dataByYear = {};
             response.data.forEach(doc => {
                dataByYear[doc.year] = doc;
             });
             setMetricsData(dataByYear);
         } catch (err) {
             console.error(err);
             setErrorMessage("Error fetching metrics data");
         }
      };
      fetchMetrics();
    }, []); // Run only once

    // --- Helper function to aggregate metrics based on current selections --- 
    // This version works on a single year document (data should have "organizations")
    function computeSelectedMetrics(data: any, org: string, project: string, team: string) {
        let metricsArr: any[] = [];
    
        if (org) {
            const orgObj = data.organizations.find((o: any) => o.name === org);
            if (!orgObj) return null;
    
            if (project) {
                const projObj = orgObj.projects.find((p: any) => p.name === project);
                if (!projObj) return null;
    
                if (team) {
                    const teamObj = projObj.teams.find((t: any) => t.name === team);
                    if (!teamObj) return null;
                    metricsArr = [teamObj.metrics];
                } else {
                    metricsArr = projObj.teams.map((t: any) => t.metrics);
                }
            } else {
                metricsArr = orgObj.projects.flatMap((p: any) => p.teams.map((t: any) => t.metrics));
            }
        } else {
            metricsArr = data.organizations.flatMap((o: any) => 
                o.projects.flatMap((p: any) => p.teams.map((t: any) => t.metrics))
            );
        }
    
        if (!metricsArr.length) return null;
    
        // Filter out any invalid metric objects
        metricsArr = metricsArr.filter(m => m && Object.keys(m).length);
    
        if (!metricsArr.length) return null;
    
        // Initialize aggregated object based on keys of the first metric object
        const aggregated: any = {};
        const keys = Object.keys(metricsArr[0]);
    
        for (const key of keys) {
            aggregated[key] = Array(12).fill(0);
        }
    
        // Aggregate metrics (summing over teams)
        metricsArr.forEach(m => {
            keys.forEach(key => {
                if (m[key] && m[key].length === 12) { // Ensure valid data array
                    for (let i = 0; i < 12; i++) {
                        aggregated[key][i] += m[key][i];
                    }
                }
            });
        });
    
        return aggregated;
    }

    // --- Compute the aggregated (or "rolled") metrics whenever data, selections, or year changes ---
    useEffect(() => {
        if (!metricsData) return;
    
        let aggregated;
    
        if (year === '2024') {
            // Use 2024 data as-is
            aggregated = computeSelectedMetrics(metricsData["2024"], org, selectId, team);
        } else if (year === '2025') {
            // For 2025, we want to use rolling data:
            // Use the available 2025 data up to the current month,
            // and fill in the remaining months from 2024 data.
            const agg2025 = computeSelectedMetrics(metricsData["2025"], org, selectId, team);
            const agg2024 = computeSelectedMetrics(metricsData["2024"], org, selectId, team);
    
            if (agg2025 && agg2024) {
                // Get current month index (0 = Jan, 1 = Feb, etc.)
                const currentMonthIndex = new Date().getMonth();
                // For each metric, replace months after currentMonthIndex with 2024 values
                for (const key in agg2025) {
                    for (let i = currentMonthIndex + 1; i < 12; i++) {
                        agg2025[key][i] = agg2024[key][i];
                    }
                }
                aggregated = agg2025;
            } else {
                aggregated = agg2025 || agg2024;
            }
        }
    
        console.log("Aggregated Metrics:", aggregated);
        setMonthlyMetrics(aggregated);
    }, [metricsData, org, selectId, team, year]);

    // --- Update the dropdown filtering to use metricsData ---
    const filteredOrgs = metricsData 
      ? metricsData["2024"].organizations.filter((o: any) => o.name.toLowerCase().includes(searchText.toLowerCase()))
      : [];
    
    const filteredProjects = (org && metricsData) 
      ? (metricsData["2024"].organizations.find((o: any) => o.name === org)?.projects.filter((p: any) =>
              p.name.toLowerCase().includes(idSearchText.toLowerCase())) || [])
      : [];
    
    const filteredTeams = (org && selectId && metricsData) 
      ? (metricsData["2024"].organizations.find((o: any) => o.name === org)
            ?.projects.find((p: any) => p.name === selectId)
            ?.teams.filter((t: any) => t.name.toLowerCase().includes(teamSearchText.toLowerCase())) || [])
      : [];
    
    // Create dynamic metricMapping from available metrics
    const chartLabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const metricMapping = {};
    
    // If monthlyMetrics exists, dynamically create the metric mapping
    if (monthlyMetrics) {
        // Get all metric keys from the data
        const metricKeys = Object.keys(monthlyMetrics);
        
        // For each metric key, create a chart configuration
        metricKeys.forEach(key => {
            // Get display config for this metric, or use defaults
            const config = metricDisplayConfig[key] || {
                displayName: key,
                category: "Other",
                backgroundColor: "rgba(128, 128, 128, 0.4)", 
                borderColor: "rgba(128, 128, 128, 1)"
            };
            
            // Create the chart data configuration
            metricMapping[key] = {
                displayName: config.displayName,
                category: config.category,
                labels: chartLabels,
                datasets: [
                    {
                        label: config.displayName,
                        data: monthlyMetrics[key],
                        backgroundColor: config.backgroundColor,
                        borderColor: config.borderColor,
                        borderWidth: 1,
                    },
                ],
            };
        });
    }
    
    // Get metrics for current tab category
    const currentCategory = tabCategories[currentTab];
    const filteredMetrics = Object.entries(metricMapping).filter(([key, value]) => {
        if (currentTab === 0) {
            // For favorites tab, show only pinned metrics
            return pinnedMetrics.includes(key);
        } else {
            // For other tabs, filter by category
            return value.category.toLowerCase() === tabCategories[currentTab].toLowerCase();
        }
    });
    
    return (
        <Box p={2}>
            {errorMessage && <Typography color="error">{errorMessage}</Typography>}
            {/* Show loading message if metrics have not been fetched yet */}
            {!metricsData && !errorMessage && <Typography>Loading data...</Typography>}
            <Box
                sx={{
                    display: "flex",
                    flexWrap: "wrap",
                    m: "2vh",
                    justifyContent: "space-between",
                    width: "100%",
                }}
            >   
                <Box sx={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    padding: "0 1%",
                }}>
                    <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                        Organization
                    </Typography>
                    <Select
                        style={{
                            borderRadius: "20px",
                            minWidth: "200px",
                            marginBottom: "1vh",
                            boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                            fontSize: "16px",
                            background: theme.palette.background.paper,
                            color: theme.palette.text.primary,
                        }}
                        MenuProps={{ autoFocus: false }}
                        value={org}
                        onChange={handleOrgChange}
                        displayEmpty
                        onClose={() => setSearchText("")}
                    >
                        <ListSubheader>
                            <TextField
                                size="small"
                                autoFocus
                                placeholder="Type to search..."
                                fullWidth
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <SearchIcon />
                                        </InputAdornment>
                                    )
                                }}
                                onChange={(e) => setSearchText(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key !== "Escape") {
                                        e.stopPropagation();
                                    }
                                }}
                            />
                        </ListSubheader>
                        <MenuItem value="">All Organizations</MenuItem>
                        {filteredOrgs.map((o: any) => (
                            <MenuItem key={o.name} value={o.name}>
                                {o.name}
                            </MenuItem>
                        ))}
                    </Select>
                </Box>
                <Box sx={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    padding: "0 1%",
                    transition: "display 1s ease-in-out",
                }}>
                    <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                        Projects
                    </Typography>
                    <Select
                        style={{
                            borderRadius: "20px",
                            minWidth: "200px",
                            marginBottom: "1vh",
                            boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                            fontSize: "16px",
                            background: theme.palette.background.paper,
                            color: theme.palette.text.primary,
                        }}
                        value={selectId}
                        onChange={handleIdChange}
                        disabled={!org}
                        displayEmpty
                        MenuProps={{ autoFocus: false }}
                        onClose={() => setIdSearchText("")}
                    >
                        <ListSubheader>
                            <TextField
                                size="small"
                                autoFocus
                                placeholder="Type to search..."
                                fullWidth
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <SearchIcon />
                                        </InputAdornment>
                                    )
                                }}
                                onChange={(e) => setIdSearchText(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key !== "Escape") {
                                        e.stopPropagation();
                                    }
                                }}
                            />
                        </ListSubheader>
                        <MenuItem value="">All Projects</MenuItem>
                        {filteredProjects.map((p: any) => (
                            <MenuItem key={p.name} value={p.name}>
                                {p.name}
                            </MenuItem>
                        ))}
                    </Select>
                </Box>
                    
                <Box sx={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    padding: "0 1%",
                    transition: "display 1s ease-in-out",
                }}>
                    <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                        Teams
                    </Typography>
                    <Select
                        style={{
                            borderRadius: "20px",
                            minWidth: "200px",
                            marginBottom: "1vh",
                            boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                            fontSize: "16px",
                            background: theme.palette.background.paper,
                            color: theme.palette.text.primary,
                        }}
                        value={team}
                        onChange={handleTeamChange}
                        disabled={!org || !selectId}
                        displayEmpty
                        MenuProps={{ autoFocus: false }}
                        onClose={() => setTeamSearchText("")}
                    >
                        <ListSubheader>
                            <TextField
                                size="small"
                                autoFocus
                                placeholder="Type to search..."
                                fullWidth
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <SearchIcon />
                                        </InputAdornment>
                                    )
                                }}
                                onChange={(e) => setTeamSearchText(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key !== "Escape") {
                                        e.stopPropagation();
                                    }
                                }}
                            />
                        </ListSubheader>
                        <MenuItem value="">All Teams</MenuItem>
                        {filteredTeams.map((t: any) => (
                            <MenuItem key={t.name} value={t.name}>
                                {t.name}
                            </MenuItem>
                        ))}
                    </Select>
                </Box>
            </Box>
            
            <Box sx={{ width: '100%', bgcolor: 'background.paper', borderRadius: '40px'}}>
                <Tabs 
                    value={currentTab} 
                    onChange={handleTabChange} 
                    sx={{
                        borderBottom: 1,
                        borderColor: 'divider',
                        mb: 2
                    }}
                >
                    <Tab 
                        label={
                            <Box sx={{ display: 'flex', alignItems: 'center', borderRadius: '40px'}}>
                                Favourites <PushPinIcon sx={{ ml: 1 }} />
                            </Box>
                        } 
                        sx={{backgroundColor: '#ccffcc'}}
                    />
                    <Tab label="Efficiency" />
                    <Tab label="Quality" />
                    <Tab label="Development" />
                    <Tab label="Innovation" />
                    <Tab label="Support" />
                    <Tab label="Year" />
                    <Select
                        value={year}
                        onChange={(e) => setYear(e.target.value)}
                        displayEmpty
                        style={{
                            borderRadius: "20px",
                            minWidth: "100px",
                            marginLeft: "auto",
                            boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                            fontSize: "16px",
                            background: theme.palette.background.paper,
                            color: theme.palette.text.primary,
                        }}
                    >
                        <MenuItem value="2024" onClick={() => setYear('2024')}>2024</MenuItem>
                        <MenuItem value="2025" onClick={() => setYear('2025')}>2025</MenuItem>
                    </Select>
                </Tabs>
                {/* Main content area for metrics */}
                <TabPanel value={currentTab} index={currentTab}>
                    {currentTab === 0 && pinnedMetrics.length === 0 ? (
                        <Typography>No Pinned Metrics found</Typography>
                    ) : monthlyMetrics ? (
                        <Box
                            sx={{
                                display: "grid",
                                gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" },
                                gap: 4,
                                width: "100%",
                                transition: "opacity 0.5s ease-in-out",
                            }}
                        >
                            {/* Display metrics relevant to the current tab */}
                            {Object.entries(metricMapping)
                                .filter(([key, value]) => {
                                    if (currentTab === 0) {
                                        // For Favorites tab
                                        return pinnedMetrics.includes(key);
                                    } else {
                                        // For category tabs, match the category
                                        return value.category.toLowerCase() === tabCategories[currentTab].toLowerCase();
                                    }
                                })
                                .map(([key, value]) => (
                                    <DataCard
                                        key={key}
                                        title={value.displayName || key}
                                        data={{
                                            labels: value.labels,
                                            datasets: value.datasets
                                        }}
                                        onPin={() => handlePin(key)}
                                        isPinned={pinnedMetrics.includes(key)}
                                        note={notes[key]}
                                        onNoteChange={(noteValue) => handleNoteChange(key, noteValue)}
                                    />
                                ))
                            }
                        </Box>
                    ) : (
                        <Typography>No metrics data available for this selection</Typography>
                    )}
                </TabPanel>
            </Box>
        </Box>
    );
}
