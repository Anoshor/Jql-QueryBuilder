function computeSelectedMetrics(data: any, org: string, project: string, team: string) {
  let metricsArr: any[] = [];

  // Helper to unwrap metrics from a team object.
  const getTeamMetrics = (t: any) => {
    return t.metrics && t.metrics.metrics ? t.metrics.metrics : t.metrics;
  };

  if (org) {
    const orgObj = data.organizations.find((o: any) => o.name === org);
    if (!orgObj) return null;

    if (project) {
      const projObj = orgObj.projects.find((p: any) => p.name === project);
      if (!projObj) return null;

      if (team) {
        const teamObj = projObj.teams.find((t: any) => t.name === team);
        if (!teamObj) return null;
        metricsArr = [getTeamMetrics(teamObj)];
      } else {
        // Aggregate data from all teams under the selected project
        metricsArr = projObj.teams.map((t: any) => getTeamMetrics(t));
      }
    } else {
      // Aggregation at org level: include metrics from all teams in every project under the organization.
      metricsArr = orgObj.projects.flatMap((p: any) =>
        p.teams.map((t: any) => getTeamMetrics(t))
      );
    }
  } else {
    // If no org is selected, aggregate data from every team in every organization.
    metricsArr = data.organizations.flatMap((o: any) =>
      o.projects.flatMap((p: any) =>
        p.teams.map((t: any) => getTeamMetrics(t))
      )
    );
  }

  if (!metricsArr.length) return null;
  metricsArr = metricsArr.filter((m) => m && Object.keys(m).length);
  if (!metricsArr.length) return null;

  // Initialize aggregated object using the keys from the first metric object
  const aggregated: any = {};
  const keys = Object.keys(metricsArr[0]);
  for (const key of keys) {
    aggregated[key] = Array(12).fill(0);
  }

  // Sum up the values for each metric across all teams
  metricsArr.forEach((m) => {
    keys.forEach((key) => {
      if (m[key] && m[key].length === 12) {
        for (let i = 0; i < 12; i++) {
          aggregated[key][i] += m[key][i];
        }
      }
    });
  });

  // Optionally, round each aggregated value to 2 decimal places
  for (const key in aggregated) {
    aggregated[key] = aggregated[key].map((value: number) => Number(value.toFixed(2)));
  }

  return aggregated;
}
