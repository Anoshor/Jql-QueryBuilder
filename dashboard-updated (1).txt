import { useEffect, useState } from "react";
import { Box, Select, MenuItem, Typography, ListSubheader, TextField, InputAdornment, Tabs, Tab } from "@mui/material";
import axios from "axios";
import { useTheme } from "@emotion/react";
import SearchIcon from "@mui/icons-material/Search";
import PushPinIcon from '@mui/icons-material/PushPin';
import DataCard from "../components/DataCard";

interface TabPanelProps {
    children?: React.ReactNode;
    index: number;
    value: number;
}

function TabPanel(props: TabPanelProps) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`metrics-tabpanel-${index}`}
            aria-labelledby={`metrics-tab-${index}`}
            {...other}
        >
            {value === index && (
                <Box sx={{ p: 3 }}>
                    {children}
                </Box>
            )}
        </div>
    );
}

interface SavedMapping {
  org: string;
  projectList: Record<string, {
    teams: string[];
    members: Record<string, string[]>;
  }>;
}

// Define metric display configurations
const metricDisplayConfig = {
    "BugsResolvedCount": {
        displayName: "Bugs Resolved Count",
        category: "Efficiency",
        backgroundColor: "orange",
        borderColor: "darkorange"
    },
    "MeanTimeToResolve": {
        displayName: "MTTR",
        category: "Efficiency",
        backgroundColor: "rgba(0, 76, 255, 0.4)",
        borderColor: "rgb(0, 7, 99)"
    },
    "BugsEscapeRate": {
        displayName: "Bugs Escape Rate",
        category: "Quality",
        backgroundColor: "orange",
        borderColor: "darkorange"
    },
    "EpicsDelivered": {
        displayName: "Epics Delivered",
        category: "Development",
        backgroundColor: "rgba(255, 206, 86, 0.4)",
        borderColor: "rgba(255, 206, 86, 1)"
    },
    "DevelopmentCycleTime": {
        displayName: "Development Cycle Time",
        category: "Development",
        backgroundColor: "rgba(75, 192, 192, 0.4)",
        borderColor: "rgba(75, 192, 192, 1)"
    },
    "StoriesDelivered": {
        displayName: "Stories Delivered",
        category: "Development",
        backgroundColor: "rgba(153, 102, 255, 0.4)",
        borderColor: "rgba(153, 102, 255, 1)"
    },
    "StoryPointsCompleted": {
        displayName: "Story Points Completed",
        category: "Development",
        backgroundColor: "rgba(255, 99, 132, 0.4)",
        borderColor: "rgba(255, 99, 132, 1)"
    }
};

// Map tab indices to category names
const tabCategories = {
    0: "Favorites",
    1: "Efficiency",
    2: "Quality",
    3: "Development",
    4: "Innovation",
    5: "Support"
};

export default function Dashboard({org = "", setOrg, team = "", setTeam, selectId = "", setselectId}) {
    
    const [errorMessage, setErrorMessage] = useState("");
    const [monthlyMetrics, setMonthlyMetrics] = useState(null);
    const [searchText, setSearchText] = useState("");
    const [idSearchText, setIdSearchText] = useState("");
    const [teamSearchText, setTeamSearchText] = useState("");
    const [currentTab, setCurrentTab] = useState(1);
    const [pinnedMetrics, setPinnedMetrics] = useState<string[]>([]);
    const [notes, setNotes] = useState({});
    
    const theme = useTheme();
    // New state for holding the fetched metrics data from the backend
    const [metricsData, setMetricsData] = useState<any>(null);
    const handleOrgChange = (event) => {
        setOrg(event.target.value);
        setselectId(""); // Reset selectId when org changes
        setTeam(""); // Reset team when org changes
    }
    const handleIdChange = (event) => {
        setselectId(event.target.value);
        setTeam(""); // Reset team when selectId changes
    }
    const handleTeamChange = (event) => {
        setTeam(event.target.value);
    }
    const handleTabChange = (event, newValue) => {
        setCurrentTab(newValue);
    };
    
    useEffect(() => {
        console.log("org: ", org);
        console.log("selectId: ", selectId);    
        console.log("team: ", team);
    }, [org, selectId, team]);
    const handlePin = (metric) => {
        setPinnedMetrics((prev) => 
            prev.includes(metric) ? prev.filter((m) => m !== metric) : [...prev, metric]
        );
    }
    const handleNoteChange = (metric, value) => {
        setNotes((prev) => (
            {
                ...prev,
                [metric]: value,}
        ));
    };
    // New useEffect to fetch metrics data from your backend
    useEffect(() => {
      const fetchMetrics = async () => {
         try {
             const response = await axios.get("http://localhost:5000/metrics");
             if(response.data && response.data.length > 0){
                 // Store all metrics data
                 setMetricsData(response.data);
             } else {
                 setErrorMessage("No metrics data available");
             }
         } catch (err) {
             console.error(err);
             setErrorMessage("Error fetching metrics data");
         }
      };
      fetchMetrics();
    }, []);
    // --- New effect: compute aggregated (or selected) metrics when data or selections change ---
    // Get the current date
    const [currentDate, setCurrentDate] = useState(new Date());
    const currentMonth = currentDate.getMonth(); // 0-11
    const currentYear = currentDate.getFullYear(); // e.g., 2025
    
    useEffect(() => {
        if (!metricsData || !metricsData.length) return;
        
        // Create a rolling 12-month dataset
        const rollingYearData = createRollingYearData(metricsData, currentMonth, currentYear);
        
        // Compute selected metrics using the rolling year data
        const aggregated = computeSelectedMetrics(
          rollingYearData,
          org || "",
          selectId || "",
          team || ""
        );
        
        console.log("Aggregated Metrics:", aggregated);
        setMonthlyMetrics(aggregated);
    }, [metricsData, org, selectId, team, currentMonth, currentYear]);
    
    // Function to create a rolling 12-month dataset from multiple year data
    function createRollingYearData(allData: any[], currentMonth: number, currentYear: number) {
        // Deep clone the most recent year's data as our base
        const mostRecentYearData = allData.find(d => parseInt(d.year) === currentYear);
        if (!mostRecentYearData) return null;
        
        const rollingYearData = JSON.parse(JSON.stringify(mostRecentYearData));
        
        // Find previous year's data if it exists
        const previousYearData = allData.find(d => parseInt(d.year) === currentYear - 1);
        
        if (previousYearData) {
            // For each organization in the rolling year data
            rollingYearData.organizations.forEach((org: any) => {
                // Find the matching organization in the previous year
                const prevOrg = previousYearData.organizations.find((o: any) => o.name === org.name);
                if (!prevOrg) return;
                
                // For each project in the current organization
                org.projects.forEach((project: any) => {
                    // Find matching project in previous year
                    const prevProject = prevOrg.projects.find((p: any) => p.name === project.name);
                    if (!prevProject) return;
                    
                    // For each team in the current project
                    project.teams.forEach((team: any) => {
                        // Find matching team in previous year
                        const prevTeam = prevProject.teams.find((t: any) => t.name === team.name);
                        if (!prevTeam) return;
                        
                        // Replace zeroes in the current year with data from previous year for months beyond the current month
                        Object.keys(team.metrics).forEach(metricKey => {
                            for (let month = currentMonth + 1; month < 12; month++) {
                                team.metrics[metricKey][month] = prevTeam.metrics[metricKey][month];
                            }
                        });
                    });
                });
            });
        }
        
        // Reorder the months to start from current month to 12 months ago
        rollingYearData.organizations.forEach((org: any) => {
            org.projects.forEach((project: any) => {
                project.teams.forEach((team: any) => {
                    Object.keys(team.metrics).forEach(metricKey => {
                        const metricArray = team.metrics[metricKey];
                        const reordered = [];
                        
                        // Start from current month and go back 12 months
                        for (let i = 0; i < 12; i++) {
                            // Calculate the month index (wrapping around from current month back 12 months)
                            const monthIndex = (currentMonth - i + 12) % 12;
                            reordered.push(metricArray[monthIndex]);
                        }
                        
                        // Reverse to get chronological order (12 months ago to current month)
                        team.metrics[metricKey] = reordered.reverse();
                    });
                });
            });
        });
        
        return rollingYearData;
    }

    // --- Helper function to aggregate metrics based on current selections ---
    function computeSelectedMetrics(data: any, org: string, project: string, team: string) {
        if (!data) return null;
        
        let metricsArr: any[] = [];
        if (org) {
           const orgObj = data.organizations.find((o: any) => o.name === org);
           if (!orgObj) return null;
           if (project) {
             const projObj = orgObj.projects.find((p: any) => p.name === project);
             if (!projObj) return null;
             if (team) {
               const teamObj = projObj.teams.find((t: any) => t.name === team);
               if (!teamObj) return null;
               metricsArr = [teamObj.metrics];
             } else {
               metricsArr = projObj.teams.map((t: any) => t.metrics);
             }
           } else {
             metricsArr = orgObj.projects.flatMap((p: any) => p.teams.map((t: any) => t.metrics));
           }
        } else {
           metricsArr = data.organizations.flatMap((o: any) => o.projects.flatMap((p: any) => p.teams.map((t: any) => t.metrics)));
        }
        if (metricsArr.length === 0) return null;
        // Aggregate by key (assuming keys like "metric1" and "metric2" exist and each is an array of 12 numbers)
        const keys = Object.keys(metricsArr[0]);
        const aggregated: any = {};
        for (const key of keys) {
          aggregated[key] = Array(12).fill(0);
        }
        for (const m of metricsArr) {
          for (const key of keys) {
              for (let i = 0; i < 12; i++) {
                  aggregated[key][i] += m[key][i];
              }
          }
        }
        // Always show sum values, regardless of how many teams are selected
        return aggregated;
    }
    // --- Update the dropdown filtering to use metricsData ---
    const filteredOrgs = metricsData 
      ? metricsData.organizations.filter((o: any) => o.name.toLowerCase().includes(searchText.toLowerCase()))
      : [];
    
    const filteredProjects = (org && metricsData) 
      ? (metricsData.organizations.find((o: any) => o.name === org)?.projects.filter((p: any) =>
              p.name.toLowerCase().includes(idSearchText.toLowerCase())) || [])
      : [];
    
    const filteredTeams = (org && selectId && metricsData) 
      ? (metricsData.organizations.find((o: any) => o.name === org)
            ?.projects.find((p: any) => p.name === selectId)
            ?.teams.filter((t: any) => t.name.toLowerCase().includes(teamSearchText.toLowerCase())) || [])
      : [];

    // Create dynamic metricMapping from available metrics
    // Generate rolling year labels based on current month
    const generateRollingYearLabels = () => {
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const labels = [];
        
        // Start from 12 months ago and build up to current month
        for (let i = 11; i >= 0; i--) {
            const monthIndex = (currentMonth - i + 12) % 12;
            const year = (monthIndex > currentMonth) ? currentYear - 1 : currentYear;
            labels.push(`${monthNames[monthIndex]} ${year.toString().slice(2)}`);
        }
        
        return labels;
    };
    
    const chartLabels = generateRollingYearLabels();
    const metricMapping = {};
    
    // If monthlyMetrics exists, dynamically create the metric mapping
    if (monthlyMetrics) {
        // Get all metric keys from the data
        const metricKeys = Object.keys(monthlyMetrics);
        
        // For each metric key, create a chart configuration
        metricKeys.forEach(key => {
            // Get display config for this metric, or use defaults
            const config = metricDisplayConfig[key] || {
                displayName: key, // Use the raw key name if no display name is defined
                category: "Other",
                backgroundColor: "rgba(128, 128, 128, 0.4)", 
                borderColor: "rgba(128, 128, 128, 1)"
            };
            
            // Create the chart data configuration
            metricMapping[key] = {
                displayName: config.displayName,
                category: config.category,
                labels: chartLabels,
                datasets: [
                    {
                        label: config.displayName,
                        data: monthlyMetrics[key],
                        backgroundColor: config.backgroundColor,
                        borderColor: config.borderColor,
                        borderWidth: 1,
                    },
                ],
            };
        });
    }

    // Get metrics for current tab category
    const currentCategory = tabCategories[currentTab];
    const filteredMetrics = Object.entries(metricMapping).filter(([key, value]) => {
        if (currentTab === 0) {
            // For favorites tab, show only pinned metrics
            return pinnedMetrics.includes(key);
        } else {
            // For other tabs, filter by category
            return value.category === currentCategory;
        }
    });

    return (
        <Box p={2}>            
            {errorMessage && <Typography color="error">{errorMessage}</Typography>}
            {/* Show loading message if metrics have not been fetched yet */}
            {!metricsData && !errorMessage && <Typography>Loading data...</Typography>}
            <Box
                sx={{
                    display: "flex",
                    flexWrap: "wrap",
                    m: "2vh",
                    justifyContent: "space-between",
                    width: "100%",
                }}
            >   
            <Box sx={{
                display: "flex",
                flexDirection: "column",
                flex: 1,
                padding: "0 1%",
            }}>
                <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                    Organization
                </Typography>
                <Select
                    style={{
                        borderRadius: "20px",
                        minWidth: "200px",
                        marginBottom: "1vh",
                        boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                        fontSize: "16px",
                        background: theme.palette.background.paper,
                        color: theme.palette.text.primary,
                    }}
                    MenuProps={{ autoFocus: false }}
                    value={org}
                    onChange={handleOrgChange}
                    displayEmpty
                    onClose={() => setSearchText("")}
                >
                    <ListSubheader>
                        <TextField
                            size="small"
                            autoFocus
                            placeholder="Type to search..."
                            fullWidth
                            InputProps={{
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <SearchIcon />
                                    </InputAdornment>
                                )
                            }}
                            onChange={(e) => setSearchText(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key !== "Escape") {
                                    e.stopPropagation();
                                }
                            }}
                        />
                    </ListSubheader>
                    <MenuItem value="">All Organizations</MenuItem>
                    {filteredOrgs.map((o: any) => (
                        <MenuItem key={o.name} value={o.name}>
                            {o.name}
                        </MenuItem>
                    ))}
                </Select>
            </Box>
            <Box sx={{
                display: "flex",
                flexDirection: "column",
                flex: 1,
                padding: "0 1%",
                transition: "display 1s ease-in-out",
            }}>
                <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                    Projects
                </Typography>
                <Select
                    style={{
                        borderRadius: "20px",
                        minWidth: "200px",
                        marginBottom: "1vh",
                        boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                        fontSize: "16px",
                        background: theme.palette.background.paper,
                        color: theme.palette.text.primary,
                    }}
                    value={selectId}
                    onChange={handleIdChange}
                    disabled={!org}
                    displayEmpty
                    MenuProps={{ autoFocus: false }}
                    onClose={() => setIdSearchText("")}
                >
                    <ListSubheader>
                        <TextField
                            size="small"
                            autoFocus
                            placeholder="Type to search..."
                            fullWidth
                            InputProps={{
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <SearchIcon />
                                    </InputAdornment>
                                )
                            }}
                            onChange={(e) => setIdSearchText(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key !== "Escape") {
                                    e.stopPropagation();
                                }
                            }}
                        />
                    </ListSubheader>
                    <MenuItem value="">All Projects</MenuItem>
                    {filteredProjects.map((p: any) => (
                        <MenuItem key={p.name} value={p.name}>
                            {p.name}
                        </MenuItem>
                    ))}
                </Select>
            </Box>
                
            <Box sx={{
                display: "flex",
                flexDirection: "column",
                flex: 1,
                padding: "0 1%",
                transition: "display 1s ease-in-out",
            }}>
                <Typography style={{ textAlign: "left", paddingLeft: "10px", color: "#4a4a4a" }} variant="h6">
                    Teams
                </Typography>
                <Select
                    style={{
                        borderRadius: "20px",
                        minWidth: "200px",
                        marginBottom: "1vh",
                        boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                        fontSize: "16px",
                        background: theme.palette.background.paper,
                        color: theme.palette.text.primary,
                    }}
                    value={team}
                    onChange={handleTeamChange}
                    disabled={!org || !selectId}
                    displayEmpty
                    MenuProps={{ autoFocus: false }}
                    onClose={() => setTeamSearchText("")}
                >
                    <ListSubheader>
                        <TextField
                            size="small"
                            autoFocus
                            placeholder="Type to search..."
                            fullWidth
                            InputProps={{
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <SearchIcon />
                                    </InputAdornment>
                                )
                            }}
                            onChange={(e) => setTeamSearchText(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key !== "Escape") {
                                    e.stopPropagation();
                                }
                            }}
                        />
                    </ListSubheader>
                    <MenuItem value="">All Teams</MenuItem>
                    {filteredTeams.map((t: any) => (
                        <MenuItem key={t.name} value={t.name}>
                            {t.name}
                        </MenuItem>
                    ))}
                </Select>
            </Box>
            </Box>
            
            <Box sx={{ width: '100%', bgcolor: 'background.paper', borderRadius: '40px'}}>
                <Tabs 
                    value={currentTab} 
                    onChange={handleTabChange} 
                    sx={{
                        borderBottom: 1,
                        borderColor: 'divider',
                        mb: 2
                    }}
                >
                    <Tab 
                        label={
                            <Box sx={{ display: 'flex', alignItems: 'center', borderRadius: '40px'}}>
                                Favourites <PushPinIcon sx={{ ml: 1 }} />
                            </Box>
                        } 
                        sx={{backgroundColor: '#ccffcc'}}
                    />
                    <Tab label="Efficiency" />
                    <Tab label="Quality" />
                    <Tab label="Development" />
                    <Tab label="Innovation" />
                    <Tab label="Support" />
                </Tabs>

                {/* Main content area for metrics */}
                <TabPanel value={currentTab} index={currentTab}>
                    {currentTab === 0 && pinnedMetrics.length === 0 ? (
                        <Typography>No Pinned Metrics found</Typography>
                    ) : monthlyMetrics ? (
                        <Box
                            sx={{
                                display: "grid",
                                gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" },
                                gap: 4,
                                width: "100%",
                                transition: "opacity 0.5s ease-in-out",
                            }}
                        >
                            {/* Display metrics relevant to the current tab */}
                            {Object.entries(metricMapping)
                                .filter(([key, value]) => {
                                    if (currentTab === 0) {
                                        // For Favorites tab
                                        return pinnedMetrics.includes(key);
                                    } else {
                                        // For category tabs, match the category
                                        return value.category.toLowerCase() === tabCategories[currentTab].toLowerCase();
                                    }
                                })
                                .map(([key, value]) => (
                                    <DataCard
                                        key={key}
                                        title={value.displayName || key}
                                        data={{
                                            labels: value.labels,
                                            datasets: value.datasets
                                        }}
                                        onPin={() => handlePin(key)}
                                        isPinned={pinnedMetrics.includes(key)}
                                        note={notes[key]}
                                        onNoteChange={(noteValue) => handleNoteChange(key, noteValue)}
                                    />
                                ))
                            }
                        </Box>
                    ) : (
                        <Typography>No metrics data available for this selection</Typography>
                    )}
                </TabPanel>
            </Box>
        </Box>
    );
}
